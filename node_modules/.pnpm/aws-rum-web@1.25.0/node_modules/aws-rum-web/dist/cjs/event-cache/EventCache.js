"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventCache = void 0;
var SessionManager_1 = require("../sessions/SessionManager");
var uuid_1 = require("uuid");
var PageManager_1 = require("../sessions/PageManager");
var EventBus_1 = require("../event-bus/EventBus");
var constant_1 = require("../plugins/utils/constant");
var webClientVersion = '1.25.0';
/**
 * A cache which stores events generated by telemetry plugins.
 *
 * The event cache stores meta data and events until they are dispatched to the
 * data plane. The event cache removes the oldest event once the cache is full
 * and a new event is added.
 */
var EventCache = /** @class */ (function () {
    /**
     * @param applicationDetails Application identity and version.
     * @param batchLimit The maximum number of events that will be returned in a batch.
     * @param eventCacheSize  The maximum number of events the cache can contain before dropping events.
     * @param sessionManager  The sessionManager returns user id, session id and handles session timeout.
     * @param pageManager The pageManager returns page id.
     */
    function EventCache(applicationDetails, config, eventBus) {
        if (eventBus === void 0) { eventBus = new EventBus_1.default(); }
        var _this = this;
        this.eventBus = eventBus;
        this.events = [];
        this.candidates = new Map();
        /**
         * Update the current page interaction for the session.
         */
        this.recordPageView = function (payload) {
            if (_this.isCurrentUrlAllowed()) {
                _this.pageManager.recordPageView(payload);
            }
        };
        /**
         * Add an event to the cache and reset the session timer.
         *
         * If the session is being recorded, the event will be recorded.
         * If the session is not being recorded, the event will not be recorded.
         *
         * @param type The event schema.
         * @param eventData The event data.
         */
        this.recordEvent = function (type, eventData) {
            if (!_this.enabled) {
                return;
            }
            if (_this.isCurrentUrlAllowed()) {
                if (type !== constant_1.SESSION_START_EVENT_TYPE) {
                    // Only refresh session if not session start event
                    // to avoid recursive loop.
                    _this.sessionManager.getSession();
                }
                if (_this.sessionManager.canRecord()) {
                    _this.sessionManager.incrementSessionEventCount();
                    _this.addRecordToCache(type, eventData);
                }
            }
        };
        /**
         * Adds a candidate to the cache and reset session timer
         *
         * @param eventType The event schema.
         * @param eventData The event data.
         */
        this.recordCandidate = function (eventType, eventData) {
            var session = _this.sessionManager.getSession();
            if (!_this.enabled || !_this.isCurrentUrlAllowed() || !session.record) {
                return;
            }
            var event = _this.createEvent(eventType, eventData)[0];
            // Update candidate if exists
            if (_this.candidates.has(eventType)) {
                _this.candidates.set(eventType, event);
                return;
            }
            // Record new candidate only if limits have not been reached
            if (_this.candidates.size < _this.config.candidatesCacheSize &&
                !_this.sessionManager.isLimitExceeded()) {
                _this.candidates.set(eventType, event);
                _this.sessionManager.incrementSessionEventCount();
            }
        };
        /**
         * Returns the current session (1) if a session exists and (2) if the
         * current URL is allowed. Returns undefined otherwise.
         */
        this.getSession = function () {
            if (_this.isCurrentUrlAllowed()) {
                return _this.sessionManager.getSession();
            }
            return undefined;
        };
        /**
         * Add an event to the cache.
         *
         * @param type The event schema.
         */
        this.addRecordToCache = function (type, eventData) {
            if (!_this.enabled) {
                return;
            }
            if (_this.events.length === _this.config.eventCacheSize) {
                // Drop newest event and keep the older ones
                // 1. Older events tend to be more relevant, such as session start
                //    or performance entries that are attributed to web vitals
                // 2. Dropping an old event requires linear time
                return;
            }
            var _a = _this.createEvent(type, eventData), event = _a[0], parsedEvent = _a[1];
            _this.eventBus.dispatch(EventBus_1.Topic.EVENT, parsedEvent);
            _this.events.push(event);
        };
        /** Creates a RumEvent and a ParsedRumEvent from a type and details. */
        this.createEvent = function (type, details) {
            // The data plane service model (i.e., LogEvents) does not adhere to the
            // RUM agent data model, where sessions and pages are first class
            // objects with their own attribute sets. Instead, we store session
            // attributes and page attributes together as 'meta data'.
            var metadata = __assign(__assign(__assign({}, _this.sessionManager.getAttributes()), _this.pageManager.getAttributes()), { version: '1.0.0', 'aws:client': _this.installationMethod, 'aws:clientVersion': webClientVersion });
            var partialEvent = {
                id: (0, uuid_1.v4)(),
                timestamp: new Date(),
                type: type
            };
            return [
                __assign(__assign({}, partialEvent), { details: JSON.stringify(details), metadata: JSON.stringify(metadata) }),
                __assign(__assign({}, partialEvent), { details: details, metadata: metadata })
            ];
        };
        this.appMonitorDetails = applicationDetails;
        this.config = config;
        this.enabled = true;
        this.pageManager = new PageManager_1.PageManager(config, this.recordEvent);
        this.sessionManager = new SessionManager_1.SessionManager(applicationDetails, config, this.recordEvent, this.pageManager);
        this.installationMethod = config.client;
    }
    /**
     * The event cache will record new events or new meta data.
     */
    EventCache.prototype.enable = function () {
        this.enabled = true;
    };
    /**
     * The event cache will not record new events or new meta data. Events and
     * meta data which are already in the cache will still be accessible.
     */
    EventCache.prototype.disable = function () {
        this.enabled = false;
    };
    /**
     * Returns true if the session is sampled, false otherwise.
     */
    EventCache.prototype.isSessionSampled = function () {
        return this.sessionManager.isSampled();
    };
    /**
     * Returns true if there are one or more events in the cache.
     */
    EventCache.prototype.hasEvents = function () {
        return this.events.length !== 0;
    };
    /**
     * Returns true if there are one or more event candidates in the cache.
     */
    EventCache.prototype.hasCandidates = function () {
        return this.candidates.size !== 0;
    };
    /**
     * Removes and returns the next batch of events.
     */
    EventCache.prototype.getEventBatch = function (flushCandidates) {
        if (flushCandidates === void 0) { flushCandidates = false; }
        var batch = [];
        // Prioritize candidates in the next event batch
        if (flushCandidates && this.hasCandidates()) {
            // Pull all candidates if they fit in the batch
            if (this.candidates.size <= this.config.batchLimit) {
                batch = Array.from(this.candidates.values());
                this.candidates.clear();
            }
            else {
                // Pull candidates in FIFO order until batch limit is reached
                var i = 0;
                for (var _i = 0, _a = Array.from(this.candidates.keys()); _i < _a.length; _i++) {
                    var key = _a[_i];
                    if (i++ >= this.config.batchLimit) {
                        break;
                    }
                    var event_1 = this.candidates.get(key);
                    if (event_1) {
                        batch.push(event_1);
                        this.candidates.delete(key);
                    }
                }
            }
        }
        // Use remaining capacity for regular events.
        if (this.events.length) {
            if (this.events.length <= this.config.batchLimit - batch.length) {
                batch.push.apply(batch, this.events);
                this.events = [];
            }
            else {
                // Dispatch the front of the array and retain the back of the array.
                batch.push.apply(batch, this.events.splice(0, this.config.batchLimit - batch.length));
            }
        }
        return batch;
    };
    /**
     * Returns an object containing the AppMonitor ID and application version.
     */
    EventCache.prototype.getAppMonitorDetails = function () {
        return this.appMonitorDetails;
    };
    /**
     * Returns an object containing the session ID and user ID.
     */
    EventCache.prototype.getUserDetails = function () {
        return {
            userId: this.sessionManager.getUserId(),
            sessionId: this.sessionManager.getSession().sessionId
        };
    };
    /**
     * Set custom session attributes to add them to all event metadata.
     *
     * @param payload object containing custom attribute data in the form of key, value pairs
     */
    EventCache.prototype.addSessionAttributes = function (sessionAttributes) {
        this.sessionManager.addSessionAttributes(sessionAttributes);
    };
    /**
     * Returns {@code true} if the current url matches one of the allowedPages
     * and does not match any of the deniedPages; returns {@code false}
     * otherwise.
     */
    EventCache.prototype.isCurrentUrlAllowed = function () {
        var location = document.location.toString();
        var exclude = this.config.pagesToExclude.some(function (re) {
            return re.test(location);
        });
        var include = this.config.pagesToInclude.some(function (re) {
            return re.test(location);
        });
        return include && !exclude;
    };
    return EventCache;
}());
exports.EventCache = EventCache;
