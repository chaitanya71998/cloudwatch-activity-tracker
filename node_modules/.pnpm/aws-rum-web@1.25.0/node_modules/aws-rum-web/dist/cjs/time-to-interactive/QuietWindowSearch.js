"use strict";
// Keep state of quiet window
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuietWindowSearch = void 0;
var LONG_TASK = 'longtask';
var FPS = 'fps';
var NAVIGATION = 'navigation';
var QuietWindowSearch = /** @class */ (function () {
    function QuietWindowSearch(fpsEnabled, onReport) {
        var _this = this;
        this.ttiTracker = {};
        this.ttiResolved = false;
        this.startBucket = 0;
        this.currBucket = 0;
        this.acceptedIntervals = 0;
        this.totalIntervals = 0;
        this.visuallyReadyTimestamp = 0;
        this.fpsEnabled = false;
        this.COLLECTION_PERIOD = 100;
        this.REQUIRED_ACCEPTED_INTERVALS = 5;
        this.CHECK_PERIOD = 1000; // Perform another check for TTI after this time period
        this.TTI_RESOLVE_TIMEOUT = 10000; // Declare a timeout for TTI after this time period
        this.FPS_THRESHOLD = 20 / (1000 / this.COLLECTION_PERIOD);
        this.LONG_TASK_THRESHOLD = 0;
        // On finding quiet window, report the TTI. If timed out, report nothing and cleanup listeners
        this.ttiIntervalHandler = function () {
            var isTTITimedOut = _this.totalIntervals * _this.CHECK_PERIOD > _this.TTI_RESOLVE_TIMEOUT;
            if (isTTITimedOut) {
                // TTI computation timed out. Don't attempt any more calculations
                _this.ttiResolved = true;
                _this.ttiTracker = {};
                clearInterval(_this.ttiInterval);
            }
            var endBucket = _this.computeTimeWindow();
            for (var bucket = _this.currBucket; bucket <= endBucket; bucket++) {
                _this.currBucket = bucket;
                var allTTIConditionsFulfiled = true;
                // Check long task fulfils criteria
                if (_this.isTTIConditionNotFulfilied(LONG_TASK, bucket)) {
                    allTTIConditionsFulfiled = false;
                }
                // Check FPS fulfils criteria
                if (_this.fpsEnabled &&
                    _this.isTTIConditionNotFulfilied(FPS, bucket)) {
                    allTTIConditionsFulfiled = false;
                }
                // If all conditions for a time window are not fulfiled, reset and move to next time window
                if (!allTTIConditionsFulfiled) {
                    _this.acceptedIntervals = 0;
                    continue;
                }
                // All conditions were met so its an accepted interval towards quiet window quota
                _this.acceptedIntervals += 1;
                if (_this.isTTIResolved(_this.acceptedIntervals)) {
                    _this.ttiResolved = true;
                    clearInterval(_this.ttiInterval);
                    _this.onReport({
                        name: 'TTI',
                        value: _this.computeTTIValue()
                    });
                    break;
                }
                else {
                    // TTI not yet resolvable, so continue trying
                    continue;
                }
            }
            _this.totalIntervals += 1;
        };
        this.longTaskEventListener = function () {
            var eventObserver = new PerformanceObserver(function (list) {
                // If tti resolution is done, teardown
                if (_this.ttiResolved) {
                    eventObserver.disconnect();
                }
                list.getEntries()
                    .filter(function (e) { return e.entryType === LONG_TASK; })
                    .forEach(function (event) {
                    // Add to the time buckets where the long task spreads over
                    if (event.startTime && event.duration) {
                        var endTime = event.startTime + event.duration;
                        _this.addToTracker(LONG_TASK, _this.computeTimeWindow(event.startTime), 1);
                        _this.addToTracker(LONG_TASK, _this.computeTimeWindow(endTime), 1);
                    }
                });
            });
            eventObserver.observe({
                type: LONG_TASK
            });
        };
        this.framesPerSecondListener = function () {
            // The frames per second listener measures frames per second. It does so
            // using requestAnimationFrame.  This works by increasing the frame for
            // each call in a given time bucket. For most devices and application
            // this will be 60.
            var trackFrames = function () {
                // increment FPS by 1 in tracker for time window
                _this.addToTracker(FPS, _this.computeTimeWindow(), 1);
                window.requestAnimationFrame(trackFrames);
            };
            if (!_this.ttiResolved) {
                window.requestAnimationFrame(trackFrames);
            }
        };
        this.fpsEnabled = fpsEnabled;
        this.initListeners();
        this.onReport = onReport;
    }
    // Begin search for Quiet window and TTI
    QuietWindowSearch.prototype.startTtiSearch = function (visuallyReadyTimestamp) {
        this.startBucket = Math.max(this.computeTimeWindow(visuallyReadyTimestamp), 0);
        this.currBucket = this.startBucket;
        this.acceptedIntervals = 0;
        this.totalIntervals = 0;
        this.visuallyReadyTimestamp = visuallyReadyTimestamp;
        this.ttiInterval = setInterval(this.ttiIntervalHandler, this.CHECK_PERIOD);
    };
    QuietWindowSearch.prototype.isTTIResolved = function (acceptedIntervals) {
        if (acceptedIntervals >= this.REQUIRED_ACCEPTED_INTERVALS) {
            return true;
        }
        else {
            return false;
        }
    };
    QuietWindowSearch.prototype.computeTTIValue = function () {
        /*
        TTI is the time to the start of the TTI quiet window.
        Therefore, it is the sum of the time to visually ready + time from VR to the start of the quiet window
        */
        var timeToQuietPeriodFromVisuallyReady = (this.currBucket -
            this.REQUIRED_ACCEPTED_INTERVALS -
            this.startBucket +
            1) *
            this.COLLECTION_PERIOD;
        // Cleanup
        this.ttiTracker = {};
        return this.getPrerenderedOffset(this.visuallyReadyTimestamp + timeToQuietPeriodFromVisuallyReady);
    };
    QuietWindowSearch.prototype.getPrerenderedOffset = function (tti) {
        var activationStart = this.getActivationStart();
        if (activationStart === undefined) {
            return tti;
        }
        else {
            var newTti = Math.floor(tti) - activationStart;
            // return the offset (at least 1ms)
            return newTti >= 0 ? Math.max(1, newTti) : tti;
        }
    };
    QuietWindowSearch.prototype.getActivationStart = function () {
        if (this.prerenderedOffset !== undefined) {
            // we've previously calculated, return the value
            return this.prerenderedOffset;
        }
        if (typeof document.prerendering !== 'boolean') {
            return this.prerenderedOffset;
        }
        if (window.performance) {
            var navEntry = window.performance.getEntriesByType(NAVIGATION)[0];
            if (navEntry && navEntry.activationStart) {
                this.prerenderedOffset = Math.floor(navEntry.activationStart);
            }
        }
        return this.prerenderedOffset;
    };
    QuietWindowSearch.prototype.isTTIConditionNotFulfilied = function (ttiCondition, currrentBucket) {
        /*
        Determine if TTI condition does not meet the defined acceptance criteria.

        */
        if (ttiCondition === LONG_TASK) {
            // Any intervals with no long tasks are undefined and should be marked as 0
            return (this.ttiTracker[LONG_TASK] !== undefined &&
                this.ttiTracker[LONG_TASK][currrentBucket] !== undefined &&
                this.ttiTracker[LONG_TASK][currrentBucket] >
                    this.LONG_TASK_THRESHOLD);
        }
        if (ttiCondition === FPS) {
            return (this.fpsEnabled &&
                this.ttiTracker[FPS] !== undefined &&
                this.ttiTracker[FPS][currrentBucket] !== undefined &&
                this.ttiTracker[FPS][currrentBucket] < this.FPS_THRESHOLD);
        }
    };
    QuietWindowSearch.prototype.initListeners = function () {
        // Use performance observer to record long tasks and domcontentloaded
        this.longTaskEventListener();
        // Init FPS listener if supported and enabled
        if (this.fpsEnabled && window.requestAnimationFrame !== undefined) {
            this.framesPerSecondListener();
        }
    };
    QuietWindowSearch.prototype.computeTimeWindow = function (currTime) {
        if (currTime === undefined) {
            return Math.floor(performance.now() / this.COLLECTION_PERIOD);
        }
        else {
            return Math.floor(currTime / this.COLLECTION_PERIOD);
        }
    };
    QuietWindowSearch.prototype.addToTracker = function (type, bucket, value) {
        if (!this.ttiTracker[type]) {
            this.ttiTracker[type] = [];
        }
        if (!this.ttiTracker[type][bucket]) {
            this.ttiTracker[type][bucket] = 0;
        }
        this.ttiTracker[type][bucket] += value;
    };
    QuietWindowSearch.prototype.cleanupQuietWindowSearch = function () {
        this.ttiResolved = true;
        this.ttiTracker = {};
    };
    return QuietWindowSearch;
}());
exports.QuietWindowSearch = QuietWindowSearch;
