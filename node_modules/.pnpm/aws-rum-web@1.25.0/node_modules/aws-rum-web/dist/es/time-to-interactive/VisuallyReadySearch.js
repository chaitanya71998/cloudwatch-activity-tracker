import { isFCPSupported, isLCPSupported } from '../utils/common-utils';
import { onFCP, onLCP } from 'web-vitals';
var NAVIGATION = 'navigation';
var FCP = 'FCP';
var LCP = 'LCP';
// Keep state for visually ready
var VisuallyReadySearch = /** @class */ (function () {
    function VisuallyReadySearch(quietWindow) {
        var _this = this;
        this.visuallyReadyTimestamp = 0;
        this.timeIntervals = 0;
        this.fcpSupported = false;
        this.lcpSupported = false;
        this.cleanupVisuallyReadySearch = false;
        this.CHECK_PERIOD = 1000; // Perform another check for Visually ready after this time period
        this.VISUALLY_READY_RESOLVE_TIMEOUT = 10000; // Declare a timeout for visually ready search after this time period
        this.visualReadyIntervalHandler = function () {
            var isCheckTimedOut = _this.timeIntervals * _this.CHECK_PERIOD >
                _this.VISUALLY_READY_RESOLVE_TIMEOUT;
            if (_this.isOkToResolveVisuallyReady(isCheckTimedOut)) {
                _this.visuallyReadyTimestamp = Math.max(_this.fcpTime ? _this.fcpTime : 0, _this.lcpTime ? _this.lcpTime : 0, _this.domContentLoadedEventEnd
                    ? _this.domContentLoadedEventEnd
                    : 0);
                clearInterval(_this.visualReadyInterval);
                _this.cleanupVisuallyReadySearch = true;
                _this.quietWindowSearch.startTtiSearch(_this.visuallyReadyTimestamp);
            }
            else {
                // No VR timestamps and check timed out, therefore stop searching and cleanup everything
                if (isCheckTimedOut) {
                    _this.cleanupVisuallyReadySearch = true;
                    _this.quietWindowSearch.cleanupQuietWindowSearch();
                }
            }
            _this.timeIntervals += 1;
        };
        this.navEventListener = function () {
            var eventObserver = new PerformanceObserver(function (list) {
                if (_this.cleanupVisuallyReadySearch) {
                    eventObserver.disconnect();
                }
                list.getEntries()
                    .filter(function (e) { return e.entryType === NAVIGATION; })
                    .map(function (e) { return e; })
                    .forEach(function (event) {
                    if (event.domContentLoadedEventEnd) {
                        _this.domContentLoadedEventEnd =
                            event.domContentLoadedEventEnd;
                    }
                });
            });
            eventObserver.observe({
                type: NAVIGATION,
                buffered: true
            });
        };
        this.initListeners();
        this.quietWindowSearch = quietWindow;
        this.visualReadyInterval = this.startVisualReadyInterval();
    }
    VisuallyReadySearch.prototype.startVisualReadyInterval = function () {
        return setInterval(this.visualReadyIntervalHandler, this.CHECK_PERIOD);
    };
    VisuallyReadySearch.prototype.isOkToResolveVisuallyReady = function (isCheckTimedOut) {
        /*
        Visually ready can be resolved in the following conditions:
        1) Pre timeout, all supported visually ready markers are ready
        2) Post timeout, atleast one visually ready marker is ready

        If (1) or (2) are not met visually ready can't be resolved yet
        */
        var isFullyVisuallyReady = this.lcpTime !== undefined &&
            this.fcpTime !== undefined &&
            this.domContentLoadedEventEnd !== undefined;
        var isPartiallyVisually = (this.lcpSupported && this.lcpTime !== undefined) ||
            (this.fcpSupported && this.fcpTime !== undefined) ||
            this.domContentLoadedEventEnd !== undefined;
        if (isFullyVisuallyReady) {
            return true;
        }
        else if (isCheckTimedOut && isPartiallyVisually) {
            return true;
        }
        else {
            return false;
        }
    };
    VisuallyReadySearch.prototype.handleWebVitals = function (metric) {
        var _this = this;
        if (metric.name === FCP) {
            metric.entries.forEach(function (entry) { return (_this.fcpTime = entry.startTime + entry.duration); });
        }
        if (metric.name === LCP) {
            metric.entries.forEach(function (entry) { return (_this.lcpTime = entry.startTime + entry.duration); });
        }
    };
    VisuallyReadySearch.prototype.initListeners = function () {
        var _this = this;
        this.navEventListener();
        // Record support for FCP and LCP
        this.lcpSupported = isLCPSupported();
        this.fcpSupported = isFCPSupported();
        // Use web vitals library for LCP and FCP, if supported
        if (this.fcpSupported) {
            this.fcpTime = undefined;
            onFCP(function (metric) { return _this.handleWebVitals(metric); });
        }
        if (this.lcpSupported) {
            this.lcpTime = undefined;
            onLCP(function (metric) { return _this.handleWebVitals(metric); });
        }
    };
    return VisuallyReadySearch;
}());
export { VisuallyReadySearch };
